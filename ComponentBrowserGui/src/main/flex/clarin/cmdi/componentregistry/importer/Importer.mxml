<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml"
		   xmlns:local="clarin.cmdi.componentregistry.services.*"
		   width="100%"
		   height="100%"
		   label="Import..."
		   implements="clarin.cmdi.componentregistry.common.components.RegistryView">

	<mx:Script>
		<![CDATA[
			import mx.core.UIComponent;
			import clarin.cmdi.componentregistry.common.ComponentMD;
			import clarin.cmdi.componentregistry.common.Profile;
			import clarin.cmdi.componentregistry.services.Config;
			import mx.events.ValidationResultEvent;
			import mx.collections.ArrayCollection;
			import mx.validators.Validator;
			import clarin.cmdi.componentregistry.editor.InputValidators;
			import clarin.cmdi.componentregistry.common.LabelConstants;
			import clarin.cmdi.componentregistry.common.Credentials;
			import mx.core.Application;
			import clarin.cmdi.componentregistry.common.ItemDescription;
			import mx.controls.Alert;

			private var validators:ArrayCollection = new ArrayCollection();

			[Bindable]
			private var isProfile:Boolean = true;
			[Bindable]
			private var importTypeString:String = "";

			private var loadedXML:XML;

			private function submit(event:Event):void {
				if (validate()) {
					var item:ItemDescription = new ItemDescription();
					item.description = description.text;
					item.name = nameInput.text;
					item.groupName = groupName.text;
					if (domainName.selectedIndex != -1)
						item.domainName = domainName.selectedItem.data;
					item.isProfile = isProfile;
					item.isInUserSpace = true; //We only allow import into workspace it can be published from there.
					if (loadedXML) {
						updateXMLFromFormFields(loadedXML);
						uploadSrv.upload(UploadService.NEW, item, loadedXML.toXMLString());
					} else {
						// No loaded XML. Let the upload service try with file reference
						uploadSrv.upload(UploadService.NEW, item);
					}
				}
			}

			private function validate():Boolean {
				var result:Boolean = true;
				for (var i:int; i < validators.length; i++) {
					var val:Validator = validators.getItemAt(i) as Validator;
					if (val.listener.visible) {
						var event:ValidationResultEvent = val.validate();
						if (event.type != ValidationResultEvent.VALID) {
							result = false;
						}
					}
				}
				return result;
			}

			private function setIsProfile(isProfileValue:Boolean):void {
				isProfile = isProfileValue;
				if (isProfile) {
					importTypeString = "Profile";
				} else {
					importTypeString = "Component";
				}
			}

			private function registryChange(event:UploadCompleteEvent):void {
				// Upload completed. Reset upload services and form
				uploadSrv.reset();
				clearForm();
				// Browse to uploaded item
				parentApplication.viewStack.switchToBrowse(event.itemDescription);
			}

			private function fileLoaded(event:FileLoadedEvent):void {
				var data:ByteArray = event.fileReference.data;
				if (data && data.bytesAvailable) {
					try {
						var utfBytes:String = data.readUTFBytes(data.length);
						loadedXML = new XML(utfBytes);

						// New file selected, clear all previous entries
						clearForm();
						// Set import type (profile or component) from attribute in XML
						setImportTypeFromFile(loadedXML);
						// Set name, description from values in XML
						setFormFieldsFromFile(loadedXML);
					} catch (error:Error) {
						Alert.show("Could not read the selected file. Not a valid XML file?", "Error");
						importTypeString = "Error";
						trace("Error while reading loaded file " + event.fileReference.name);
						return;
					}
				}
			}

			private function setImportTypeFromFile(resultXml:XML):void {
				if (resultXml.hasOwnProperty("@isProfile")) {
					setIsProfile(("true" == resultXml.@isProfile));
				} else {
					Alert.show("Unable to determine import type. Selected file may not be a valid component specification!", "Warning");
					importTypeString = "Unknown";
				}
			}

			private function setFormFieldsFromFile(resultXml:XML):void {
				var header:XML = getHeaderXML(resultXml);
				var component:XML = getComponentXML(resultXml);
				if (header) {
					description.text = header.Description;
				}
				if(component){
					nameInput.text = component.@name;
				}
			}

			private function updateXMLFromFormFields(xml:XML):void {
				var header:XML = getHeaderXML(xml);
				var component:XML = getComponentXML(xml);
				if (header) {
					header.Name = nameInput.text;
					header.Description = description.text;
				}
				if(component){
					component.@name = nameInput.text;
				}
			}

			private function getHeaderXML(xml:XML):XML {
				if (xml.hasOwnProperty("Header")) {
					var nodes:XMLList = xml.Header;
					if (nodes && nodes.length() > 0) {
						return nodes[0];
					}
				}
				return null;
			}
			
			private function getComponentXML(xml:XML):XML {
				if (xml.hasOwnProperty("CMD_Component")) {
					var nodes:XMLList = xml.CMD_Component;
					if (nodes && nodes.length() > 0) {
						return nodes[0];
					}
				}
				return null;
			}

			private function clearForm():void {
				importTypeString = "";
				nameInput.text = "";
				description.text = "";
				groupName.text = "";
				domainName.selectedItem = null;

				// Reset all error strings on components with validators, so previous validation error message don't show anymore
				for (var i:int; i < validators.length; i++) {
					var val:Validator = validators.getItemAt(i) as Validator;
					if (val.listener.visible) {
						(val.source as UIComponent).errorString = "";
					}
				}
			}

			private function registerNameValidator(event:Event):void {
				var validator:Validator = InputValidators.getNameValidator();
				validator.listener = event.currentTarget;
				validator.source = event.currentTarget;
				validator.property = "text";
				validators.addItem(validator);
			}

			private function registerIsRequiredValidator(event:Event, source:Object = null):void {
				var validator:Validator = InputValidators.getIsRequiredValidator();
				validator.listener = event.currentTarget;
				if (!source) {
					validator.source = event.currentTarget;
				} else {
					validator.source = source;
				}
				validator.property = "text";
				validators.addItem(validator);
			}

			public function getType():String {
				return Config.VIEW_IMPORT;
			}
		]]>
	</mx:Script>

	<local:UploadService id="uploadSrv"
						 loadBeforeUploading="true"
						 fileLoaded="fileLoaded(event)"
						 uploadComplete="registryChange(event)"/>
	<mx:VBox>
		<mx:Form>
			<mx:HBox>
				<mx:Button label="Select xml..."
						   id="btnSelect"
						   click="uploadSrv.selectXmlFile(event)"
						   creationComplete="registerIsRequiredValidator(event, txtSelectedFile)"/>
				<mx:Text id="txtSelectedFile"
						 text="{uploadSrv.selectedFile}"/>
			</mx:HBox>

			<mx:FormItem label="Type">
				<mx:Label id="importType"
						  width="300"
						  text="{importTypeString}"/>
			</mx:FormItem>
			<mx:FormItem label="Name">
				<mx:TextInput id="nameInput"
							  width="300"
							  creationComplete="registerNameValidator(event)"/>
			</mx:FormItem>
			<mx:FormItem label="Description">
				<mx:TextArea id="description"
							 width="300"
							 height="120"
							 creationComplete="registerIsRequiredValidator(event)"/>
			</mx:FormItem>
			<mx:FormItem label="Creator Name">
				<mx:Text id="creatorName"
						 width="300"
						 text="{Credentials.instance.userName}"/>
			</mx:FormItem>
			<mx:FormItem label="Domain Name">
				<mx:ComboBox id="domainName"
							 selectedIndex="-1"
							 prompt="{LabelConstants.DOMAIN_NAME_PROMPT}"
							 dataProvider="{LabelConstants.DOMAIN_NAME_DATA}"/>
			</mx:FormItem>
			<mx:FormItem label="Group Name">
				<mx:TextInput id="groupName"
							  width="300"/>
			</mx:FormItem>
			<mx:Button label="Submit"
					   click="submit(event)"/>
			<mx:ProgressBar id="uploadProgress"
							label=""
							mode="manual"
							creationComplete="uploadSrv.init(uploadProgress)"
							visible="false"/>
		</mx:Form>

		<mx:Text id="errorMessageField"
				 text="{uploadSrv.message}"/>

	</mx:VBox>

</mx:Canvas>

